package com.ecostream.order.service;

import com.ecostream.order.dto.LocationDTO;
import com.ecostream.order.dto.OrderRequestDTO;
import com.ecostream.order.dto.OrderResponseDTO;
import com.ecostream.order.entity.Order;
import com.ecostream.order.entity.OrderStatus;
import com.ecostream.order.repository.OrderRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

/**
 * Unit tests for OrderService implementation.
 * Tests follow TDD Red-Green-Refactor workflow.
 */
@ExtendWith(MockitoExtension.class)
class OrderServiceTest {

    @Mock
    private OrderRepository orderRepository;

    @InjectMocks
    private OrderServiceImpl orderService;

    private OrderRequestDTO orderRequestDTO;
    private Order savedOrder;

    @BeforeEach
    void setUp() {
        // Create a valid OrderRequestDTO with CONFIRMED status
        LocationDTO locationDTO = LocationDTO.builder()
                .latitude(37.7749)
                .longitude(-122.4194)
                .build();

        orderRequestDTO = OrderRequestDTO.builder()
                .status(OrderStatus.CONFIRMED) // Status in DTO should be overridden to PENDING
                .destination(locationDTO)
                .priority(5)
                .build();

        // Create a saved Order entity with PENDING status and generated ID
        UUID orderId = UUID.randomUUID();
        savedOrder = Order.builder()
                .id(orderId)
                .status(OrderStatus.PENDING) // Status should be set to PENDING regardless of DTO
                .destinationLatitude(37.7749)
                .destinationLongitude(-122.4194)
                .priority(5)
                .build();
    }

    @Test
    void createOrder_ShouldMapDTOToEntityAndSetStatusToPending() {
        // Arrange: Mock repository to return saved order
        when(orderRepository.save(any(Order.class))).thenReturn(savedOrder);

        // Act: Create order from DTO
        OrderResponseDTO result = orderService.createOrder(orderRequestDTO);

        // Assert: Verify repository was called with correct entity mapping
        verify(orderRepository, times(1)).save(argThat(order -> {
            // Verify status is set to PENDING (not CONFIRMED from DTO)
            assertEquals(OrderStatus.PENDING, order.getStatus(), 
                    "Order status should be set to PENDING regardless of DTO status");
            // Verify destination coordinates are mapped correctly
            assertEquals(orderRequestDTO.getDestination().getLatitude(), 
                    order.getDestinationLatitude(), 
                    "Destination latitude should be mapped from LocationDTO");
            assertEquals(orderRequestDTO.getDestination().getLongitude(), 
                    order.getDestinationLongitude(), 
                    "Destination longitude should be mapped from LocationDTO");
            // Verify priority is mapped correctly
            assertEquals(orderRequestDTO.getPriority(), order.getPriority(), 
                    "Priority should be mapped from DTO");
            // Verify ID is null (will be generated by JPA)
            assertNull(order.getId(), "Order ID should be null before save");
            return true;
        }));

        // Assert: Verify response DTO is correctly mapped from saved entity
        assertNotNull(result, "Response DTO should not be null");
        assertEquals(savedOrder.getId(), result.getId(), 
                "Response ID should match saved order ID");
        assertEquals(OrderStatus.PENDING, result.getStatus(), 
                "Response status should be PENDING");
        assertNotNull(result.getDestination(), 
                "Response destination should not be null");
        assertEquals(savedOrder.getDestinationLatitude(), 
                result.getDestination().getLatitude(), 
                "Response destination latitude should match saved order");
        assertEquals(savedOrder.getDestinationLongitude(), 
                result.getDestination().getLongitude(), 
                "Response destination longitude should match saved order");
        assertEquals(savedOrder.getPriority(), result.getPriority(), 
                "Response priority should match saved order");
    }
}
